# Speech 5

*Данный список включает в себя список всех сервисов и их портов, используемых при взаимодействии Active Directory (на всякий случай):*

- *UDP порт 88 для Kerberos авторизации.*
- *UDP и TCP порт 135 для операций взаимодействия контроллер-контроллер и контроллер-клиент.*
- *TCP порт 139 и UDP 138 для File Replication Service между контроллерами домена.*
- *UDP порт 389 для LDAP запросов от клиента к серверу.*
- *TCP и UDP порт 445 для File Replication Service*
- *TCP и UDP порт464 для смены пароля Kerberos*
- *TCP порт 3268 и 3269 для доступа к Global Catalog от клиента к контроллеру.*
- *TCP и UDP порт 53 для DNS запросов*

Первую часть занятия мы с вами посвятим обмену данными в домене - file sharing с помощью DFS, а потом поговорим про сертификаты в рамках AD.

И начнем мы сразу с практики:

— запустите 3 сервер, который Core-версия + Mikrotik + DC1.

На примере консольного сервака (Core-сервер 3 WS16-3-F1) я покажу, что с консолью мы будем минимально общаться, потому что у Windows существуют очень удобные средства администрирования таких серверов.

![Untitled](images/Untitled.png)

![Untitled](images/Untitled%201.png)

Какая суть: консольный сервер меньше весит из-за отсутсвия GUI. И вот когда у вас запускается консоль CMD, то софт, который работает с CMD - он все же запускается в графике.

То есть тут есть большое отличие от консольного Linux, в котором нет X-сервера, который отвечает за всю графику в Linux - и тут вы графику запустить не сможете, только псевдографику (что видно в консольном терминале). 

Однако в Windows так можно - в core-версии отрубили графическую анимацию и приложение explorer.exe, который здесь и не нужен, но какая-то графика все-таки есть (можно убедиться, поставив VBox Utils):

![Untitled](images/Untitled%202.png)

В Windows Server 2016 все-таки нужно поработать с терминалом для ручной настройки некоторый конфигураций, однако в Window Server 2022 сделали приложение, которое в значительной степени упрощает жизнь администраторам и позволяет практически целиком исключить консоль даже в core-версии (там нажатием кнопок и галочками производится конфигурация).

Основная задача наша сейчас:

1. Назначить IP-адрес машине;
2. Дать ей имя;
3. Ввести в домен.

Сначала мы должны перейти в Powershell:

Вбиваем в CMD команду: **powershell**

Теперь в первую очередь назначим статический IP-адрес, предварительно отключив DHCP:

**Set-NetIPInterface -InterfaceAlias Ethernet -Dhcp Disabled**

![Untitled](images/Untitled%203.png)

Теперь отключаем IPv6:

**Set-NetAdapterBinding -InterfaceAlias Ethernet -Enabled:$false -ComponentID ms_tcpip6**

Задаем новый IP-адрес:

**New-NetIPAddress -InterfaceAlias Ethernet -IPAddress 192.168.10.100 -DefaultGateway 192.168.10.254 -PrefixLength 24**

![Untitled](images/Untitled%204.png)

Прежде чем ввести компьютер в домен, что мы предварительно должны сделать?

- задать имя;
- задать DNS.

Задаем DNS:

**Set-DnsClientServerAddress -InterfaceAlias Ethernet -ServerAddress 192.168.10.200 (IP-адрес DC1)**

![Untitled](images/Untitled%205.png)

Задаем новое имя (у нас этот сервак будет AD CS и Web-server):

**Rename-Computer -NewName web-srv**

Теперь перезагружаемся:

**shutdown.exe /r**

Также для перезапуска есть команда WMI в Powershell путем запроса объекта WMI **Win32_OperatingSystem:**

**(Get-WmiObject Win32_OperatingSystem -EnableAllPrivileges).Win32Shutdown(2)**

Теперь вводим машину в домен:

**netdom join web-srv /Domain:cyber-ed.local /Userd:admpetr /Passwordd:Qq12345   ⇒ shutdown.exe /r /f**

Видим что на DC у нас появился компьютер:

![Untitled](images/Untitled%206.png)

Теперь что я хочу продемонстрировать? Вот мы установили консольный сервак, но далее для администрирования мы его не трогаем, а работаем только через DC. То есть с помощью DC мы будем упарвлять другими серверами.

Теперь на DC мы идем в Server Manager в **All Servers ⇒ ПКМ ⇒ Add Servers**.

Теперь задаем имя web-srv (CN) ⇒ переносим вправо:

![Untitled](images/Untitled%207.png)

Далее ПКМ по web-srv ⇒ Add Roles and Features ⇒ Next ⇒ Next ⇒ в Server Selection выбираем конкретную тачку + Next ⇒ Server Roles: File and Storage Services **(DFS Namespaces и DFS Replication)** ⇒ Next:

![Untitled](images/Untitled%208.png)

В Features ничего дополнительно ставить не нужно (Next) ⇒ Install ⇒ Close:

![Untitled](images/Untitled%209.png)

Один нюанс: у нас установленны роли на web-srv , но нам нужно ими управлять. Мы можем это делать с помощью Powershell.

Поэтому мы можем установить графическую оснастку на DC1 (в идеале это должен быть отдельный сервер).

Соответсвенно теперь на DC1 мы должны добавить дополнительную оснастку. Повторяем пути как делали выше, только в Server Roles ничего не выбираем, а в Features выбираем **Remote Server Administration Tools (все оснастки для удаленного управления ролями) ⇒ Role Administration Tools ⇒ File Services Tools ⇒ DFS Management Tools**:

![Untitled](images/Untitled%2010.png)

Далее Next ⇒ Install ⇒ Close:

![Untitled](images/Untitled%2011.png)

После успешной установки DFS Management Tools отобразится в Tools. Переходим в DFS Management:

![Untitled](images/Untitled%2012.png)

![Untitled](images/Untitled%2013.png)

### Теперь давайте немного поговорим о теории

Используете ли вы какие-нибудь облачные хранилища типа Yandex или Google Cloud?

Предположим вы пользователь в домене (user@cyber-ed.local).

Вам дале ноутбук, вы на него зашли, администратор сказал какие программы вы можете поставить и храните на компьютере все ваши данные.

И в один прекрасный момент ваш компьютер ломается и у вас данных нет.

Однако администратор выдает вам новый ноутбук, вы авторизуетесь и на нем все ваши данные есть. Почему?

Настройки AD позволяют синхронизировать набор директорий из папок вашего пользователя. Как фактически это происходит?

— делается сервер (FS - File Storage), у него есть огромное дисковое хранилище, и настройки пользователя, все его файлы синхронизируются с этим сервером, когда пользователь находится в домене.

Данные пользователя с помощью протокола SMB копируются на сервер.

 

Однако компания большая и пользователей очень много, то один сервер не выдержит обслуживания их всех. Поэтому есть Prime-серверная ферма, состоящая из многих подобных серверов.

Однако вопрос: а если наш пользователь все синхронизировал на на FS1, то как новый компьютер поймет, что нужно прийти именно к FS1, а не FS2?

Microsoft придумали следующее: они оградили нас от знания конкретного DNS-имени каждого FS - они все называются /cyber-ed.local.

Это и называется DFS (Distributed File System). Как она работает?

Мы настраиваем хранения данных физически на различных серверах (у них своя репликация).

Мы располагаем в отдельной системе сервере DFS набор ссылок и говорим, что ресурс, например, бухгалтерии физически хранится на FS1 . Однако для всех пользователей ресурс бухгалтерии - это \\cyber-ed\buhgalteria.

Однако если наш FS1 ломается, то DFS сам обрабатывает это исключение и находит на каком из серверов хранится копия данных с FS1 (например, FS6) и перенаправляет все запросы на FS6.

Мы настроили 2 роли DFS:

1. DFS Namespaces (та штука, которая абстрагирует пользователя от прямых путей до файлов)
2. DFS Replication (позволяет осуществлять репликацию между FS)

### Теперь приступаем к конфигурации в DFS Management:

Настроим Namespaces - то есть пространство имен.

Давайте передем на шару C$ у нашего web-srv:

**\\192.168.10.100\C$**

Давайте создадим тут папки share и test:

![Untitled](images/Untitled%2014.png)

Теперь давайте покажу как настраивать sharing в домене.

Возвращаемся в All Servers ⇒ ПКМ по web-srv ⇒ Computer Management:

![Untitled](images/Untitled%2015.png)

Далее Shared Folders ⇒ Shares ⇒ ПКМ по пустому месту ⇒ New Share…:

![Untitled](images/Untitled%2016.png)

Далее Next ⇒ Теперь указываем в пути созданную нами папку C:\test ⇒ Next ⇒ Next ⇒ Finish ⇒ Finish:

![Untitled](images/Untitled%2017.png)

![Untitled](images/Untitled%2018.png)

![Untitled](images/Untitled%2019.png)

Это значит, что теперь я могу ввести в Network в проводнике **\\web-srv\test**:

![Untitled](images/Untitled%2020.png)

Однако теперь возвращаемся в DFS Management и Namespaces.

Здесь мы создаем пространство имен для file sharing’а.

Нажимаем ПКМ по Namespaces ⇒ New Namespace…

![Untitled](images/Untitled%2021.png)

В качестве Server указываем web-srv ⇒ Next ⇒ Задаем имя пространству имен (например, cyber-ed-dfs) ⇒ Edit Setting (чтобы настроить доступ до этого пространства имен):

— тут начинается определенная сложность, так как доступ до пространства имен - это условно на видимость, так как права на сами расшариваемые папки регулируются в настройках самого ресурса, а данные настройки позволяют вам увидеть объекты sharing’а, но не прочитать, например, или изменить.

Давайте создадим кастомный пермишен, где Everyone имеет права на изменения и чтение (где изменение - это создание какого-то объекта в рамках данного пространства имен):

![Untitled](images/Untitled%2022.png)

![Untitled](images/Untitled%2023.png)

**C:\DFSRoots\cyber-ed-dfs** - локальный путь до пространства имен на файловом сервере DFS.

Далее Next ⇒ выбираем тип namespace’а (Domain-based) + указывается путь до файловой шары:

![Untitled](images/Untitled%2024.png)

Далее Next ⇒ Create ⇒ Close.

Теперь переходим в шару:

****************\\cyber-ed.local\cyber-ed-dfs****************:  

![Untitled](images/Untitled%2025.png)

Чтобы пользователи не шарились по всем другим папочкам, давайте сделаем sharing конкретного ресурса по конкретному имени:

В Namespaces ⇒ New Folder…:

![Untitled](images/Untitled%2026.png)

**Теперь зададим имя и запишем Folder targets - то есть будем задавать sharing не по физическому расположению, а по сетевому, хотя физически располагаться объект может где угодно, необязательно в C:\DFSRoots\cyber-ed-dfs:**

![Untitled](images/Untitled%2027.png)

![Untitled](images/Untitled%2028.png)

![Untitled](images/Untitled%2029.png)

Теперь задаем кастомные права для доменных администраторов и бухгалтерии:

![Untitled](images/Untitled%2030.png)

![Untitled](images/Untitled%2031.png)

В итоге видим:

![Untitled](images/Untitled%2032.png)

Теперь у нас есть физическая папка Share и ярлык на папку buhg (которая располагается внутри папки Share):

![Untitled](images/Untitled%2033.png)

И теперь путь у нас **\\cyber-ed.local\ced-dfs\buhg**. То есть теперь товарищи из бухгалтерии не могут перейти в верхнеуровневые папки, где будут располагаться другие папки.

По-хорошему папка Share здесь не должно быть.

### Центр Сертификации AD CS

Коллеги, а кто-нибудь создавал сайт?

А запрашивал ли кто-нибудь сертификат на сайт? Если да, то чей (что за организация)?

Давайте приведу пример. Например, Яндекс:

[Yandex](https://ya.ru/?utm_referrer=https://www.google.com/)

У нас слева вверху есть замочек - подключение защищено:

![Untitled](images/Untitled%2034.png)

То есть это означает, что сайт имеет действующий сертификат, выданный доверенным Центром Сертификации. То есть данные, переданные вами не могут быть прочитаны.

![Untitled](images/Untitled%2035.png)

Если мы пойдем дальше, то мы увидим следующую информацию:

- кому выдан сертификат;
- кем выдан сертификат;
- срок действия;
- отпечакти сертификата (его fingerprint).

Сертификат - это уникальный криптографический ключ, который идентифицирует владельца, отражает его личность - например, личность сайта, что он доверенный.

Сертификация является проверкой подлинности для клиента, который обращается на ресурс.

То есть у нас есть user и какой-то web-сайт. При обращении к сайту мы выходим в сеть Интернет. Учитывая среду мы можем предположить, что в рамках сетевого взаимодействия мы можем попасть не совсем туда, куда нужно было бы, а именно на недоверенный ресурс.

По этой причине важен какой гарант, как в случае с Kerberos, где сервер аутентификации и KDC валидируют себя в глазах клиента.

Для этого как раз и существуют криптографические ключи (сертификаты), которые заливаются на сам web-сайт и предоставляются пользователю для просмотра.

В данном случае используется механизм ассиметричного шифрования - когда у нас есть открытый и закрытый ключи.

То есть администратор закидывает на сайт закрытый ключ, а открытый распространяется всем желающим.

Клиенты шифруют данные с помощью открытого ключа, но данные могут быть расшифрованы только на сервере с помощью закрытого ключа.

![Untitled](images/Untitled%2036.png)

Однако тут вопрос: а почему в рамках MitM злоумышленник не может сгенерировать такую же пару ключей и распространить клиентам открытые ключи, после чего расшифровывая данные закрытыми ключами?

То есть почему мы должны доверять этим открытым ключам?

Вот для этого существуют цепочки сертификаций.

То есть данные ключи были сгенерированы специальными Удостоверящими Центрами, которые эти ключи выпустили.

А фактически пара открытый / закрытый ключи были куплены у специальной конторы. У этой конторы есть свои открытые и закрытые ключи для общения с теми, кто эти ключи закупает.

И вот таким образом у нас генерируется такая иерархическая структура.

И вот пользователь может не верить ключам, которые ему выдает web-сайт, однако он будет доверять ключам Удостоверящих Центров.

Если мы говорим конкретно про Web, то у браузеров есть собственное хранилище доверенных сертификатов, которым управляют разработчики и в котором содержатся все популярные Удостоверяющие Центры (УЦ).

![Untitled](images/Untitled%2037.png)

Однако бывают более многогранные структуры, когда есть главные УЦ, который выписывает второстепенному УЦ и тот выписывает сертификаты клиентам - это называется цепочкой сертификатов.

А также есть такая вещь, как CRL (Certification Revocation List) - список отозванных сертификатов. Данный список публикуется на самом Удостоверяющем Центре, и в нем содержится список отозванных сертификатов (в случае окончания срока действия, компрометации и т.д.).

То есть мы получаем сертификат, а далее идем на УЦ и удостоверяемся, что он отсутствует в CRL.

**Однако бывает и внутренние УЦ на основе AD.**

Для чего вообще нужны сертификаты в организации?

1. Во-первых, каждому компьютеру можно выпускать сертификат, чтобы компьютер представлял себя как доверенный.
2. Во-вторых, сертификаты нужны пользователям для того, чтобы входить на компьютер или шифровать персональные данные с помощью сертификата, или подписывать электронную почту.
3. Плюс такие сертификаты могут понадобиться внутренним сервисам (например, внутренним Web-сайтам или почте).

И вот все эти сертификаты будет выдавать внутренник УЦ. То есть на УЦ будет сгенерирован корневой сертификат RootCA.crt, которым в дальнейшем будут подписываться сертификаты для сайта (web.crt), почты (mail.crt) и так далее.

Однако в таком случае злоумышленник может скомпрометировать УЦ и RootCA, благодаря чему будет выдавать свои сертификаты клиентам.

Поэтому хорошей практикой считается поднять отдельный сервак (причем сделать его внедоменным), сделать его RootCA, выписывать сертификаты для УЦ и выключить его, чтобы, в случае компрометации УЦ, можно было бы перевыпустить сертификаты.

![Untitled](images/Untitled%2038.png)

### Давайте еще немного пробежимся по терминам.

**PKI (Public Key Infrastructure)** - инфраструктура открытых ключей. То есть это те самые комоненты, службы, задачи, которые поддерживают все решения в плане криптографии:

- распространения
- обработка
- применение
- и так далее

**X.509** - стандарт ключа, из чего он состоит и как создается.

**Центр Сертификации** - служба, которая выпускает сертификаты.

**CRL** - список отзыва сертификатов, в который публикуются недоверенные сертификаты.

**SSL / TLS ⇒ HTTPS** - стандарты шифрования в Web’е.

### Теперь практика:

Снова в Server Manager выбираем наш web-srv (он также у нас будет Web-сервером, чтобы тестировать сертификаты и ЦС) ⇒ ПКМ ⇒ Add Roles and Features…:

![Untitled](images/Untitled%2039.png)

Далее в Server Roles ⇒ ставим галочки (Web Server (IIS) и Active Directory Certificate Services):

![Untitled](images/Untitled%2040.png)

Далее Next ⇒ Next ⇒ в Role Services в Web Server Role (IIS) выбрать Management Service (для удаленного управления):

![Untitled](images/Untitled%2041.png)

Далее Next ⇒ в Role Services в AD CS выбираем Certification Authority и Certification Authority Web Enrollment:

![Untitled](images/Untitled%2042.png)

Далее Install ⇒ Close.

После всех этих установок и выдачи ролей, нам необходимо перенастроить Firewall и разрешить тарфик на наш IIS. А так как у нас web-srv консольный, то мы будем это делать через Powershell.

При этом необходим будет изменить реестр, чтобы мы могли удаленно управлять нашим Management Service IIS и стартовать его.

Снова в Server Manager выбираем наш web-srv ⇒ ПКМ ⇒ Windows Powershell.

Теперь добавляю следующие команды:

1. **Reg Add HKLM\Software\Microsoft\WebManagement\Server /V EnableRemoteManagement /T REG_DWORD /D 1 /F**
2. **netsh advfirewall firewall add rule name=”Allow IIS Web Management” dir=in action=allow service=”WMSVC”**
3. **Set-NetFirewallRule -Name “RemoteEventLogSvc-In-TCP” -Enabled True -Profile Domain**
4. **Set-NetFirewallRule -Name “RemoteEventLogSvc-NP-In-TCP” -Enabled True -Profile Domain**
5. **Set-NetFirewallRule -Name “RemoteEventLogSvc-RPCSS-In-TCP” -Enabled True -Profile Domain**
6. **net start wmsvc**
7. **Set-Service -Name wmsvc -StartupType Automatic**

Снова в Server Manager выбираем наш web-srv ⇒ ПКМ ⇒ Restart Server:

![Untitled](images/Untitled%2043.png)

Теперь на DC необходимо поставить средства для управления IIS.

Снова в Server Manager выбираем наш DC1 ⇒ ПКМ ⇒ Add Roles and Features…:

Далее в Server Roles ⇒ Web Server (IIS):

![Untitled](images/Untitled%2044.png)

Далее в Web Server Role (IIS) ⇒ Role Services ⇒ снимаю все галочки с Web Server:

![Untitled](images/Untitled%2045.png)

И поставить IIS Management Console:

![Untitled](images/Untitled%2046.png)

Далее Next ⇒ Close.

Теперь web-srv ⇒ ПКМ ⇒ Internet Information Services (IIS):

![Untitled](images/Untitled%2047.png)

Далее Start Page ⇒ ПКМ ⇒ Connect to a server…:

![Untitled](images/Untitled%2048.png)

Коннектимся к web-srv:

![Untitled](images/Untitled%2049.png)

Далее указываем доменного администратора:

![Untitled](images/Untitled%2050.png)

Далее Finish.

Теперь у нас есть полноценная оснастка для управления Web’ом. Что это значит?

Что теперь, например, с нашей 10-ки я могу зайти на наш Web-сервер. Однак он работает по протоколу HTTP:

**http://web-srv.cyber-ed.local**

![Untitled](images/Untitled%2051.png)

Подключение у нас не защищено и нам нужен сертификат. Сконфигурируем его.

При установке AD CS у нас не была настроена роль. Для это нажать на флажок в Server Manager ⇒ Configure Active Directory on th…:

![Untitled](images/Untitled%2052.png)

Далее Change…:

![Untitled](images/Untitled%2053.png)

Далее вводим креды, под кем настраивали данную роль:

![Untitled](images/Untitled%2054.png)

Далее OK ⇒ Next ⇒ в Role Services выбираем Certification Authority и Certification Authority Web Enrollment:

![Untitled](images/Untitled%2055.png)

Далее Next.

Теперь нам нужно выбрать тип ЦС. В чем различия:

1. Enterprise CA - это доменный ЦС
2. Standalone CA - это если бы хотел создать RootCA

![Untitled](images/Untitled%2056.png)

![Untitled](images/Untitled%2057.png)

Теперь нам, как Root CA, необхожимо создать Private Key:

![Untitled](images/Untitled%2058.png)

![Untitled](images/Untitled%2059.png)

![Untitled](images/Untitled%2060.png)

![Untitled](images/Untitled%2061.png)

![Untitled](images/Untitled%2062.png)

![Untitled](images/Untitled%2063.png)

Мы сгенерировали себе сертификат.

Теперь в Server Manager выбираем DC1 ⇒ ПКМ ⇒ Add Roles and Features:

![Untitled](images/Untitled%2064.png)

И в Feature доустанавливаем в Remote Server Administration Tools в Active Directory Certificate Services Tools выбираем Certification Authority Management Tools:

![Untitled](images/Untitled%2065.png)

И далее устанавливаем.

Теперь в Server Manager выбираем web-srv ⇒ ПКМ ⇒ Certification Authority:

![Untitled](images/Untitled%2066.png)

Вот что видим:

![Untitled](images/Untitled%2067.png)

Тут мы видим наш сервер, а также:

- Revoked Certificates - отозыванные сертификаты (CRL);
- Issued Certificates - выданные сертификаты;
- Pending Requests - ожидающие запроса сертификатов (клиенты могут сами запрашивать сертификаты, а запрашивать они их будут с помощью шаблонов сертификатов);
- Failed Requests - запроса, завершившиеся ошибками;
- Certificate Templates - шаблоны сертификатов.

Какие шаблоны у нас есть по-умолчанию. Тут пропустим Kerberos-аутентификацию и Domain Controller - аутентификацию. Из интересного:

**Basic EFS** - этот сертификат нужен для шифрования файловой системы.

**Web Server** - выдается для Web-серверов и дальнейшего обращения к ним.

**Computer** и **User** - для компьютера и пользователя.

**Administrator** - административный сертификат.

Справа в меню написаны свойства этого сертификаты и что он может:

![Untitled](images/Untitled%2068.png)

Теперь попробуем создать кастомный шабон. Зачем это может пригодиться?

Certificate Templates ⇒ ПКМ ⇒ Manage:

![Untitled](images/Untitled%2069.png)

Теперь давайте, например, выберем шаблон сертификата **Computer** ⇒ ПКМ ⇒ Duplicate Template:

![Untitled](images/Untitled%2070.png)

Далее выберем Compatibility Settings ⇒ Certification Authority указываем Windows Server 2016:

![Untitled](images/Untitled%2071.png)

А Certificate recipient ⇒ Windows 10 / Windows Server 2016:

![Untitled](images/Untitled%2072.png)

В General даем имя нашему шаблону, а в Valid Period указываем сколько он будет дейстовать и в Renewal period спустя какое время сертификат должен обновляться + публикуем сертификат в AD:

![Untitled](images/Untitled%2073.png)

Теперь в Subject Name указываем наименование сертификата. Например, по имени компьютера:

![Untitled](images/Untitled%2074.png)

Далее OK.

Теперь Certificates Templates ⇒ ПКМ ⇒ New ⇒ Certificate Template to Issue:

![Untitled](images/Untitled%2075.png)

И далее выбираем наш созданный шаблон - то есть мы регистрируем шаблон, чтобы в дальнейшем его выдавать клиентам:

![Untitled](images/Untitled%2076.png)

Теперь нам нужно в доверенные сертификаты добавить наш корневой сертификат Центра Сертификации, который мы сгенерировали при создании роли CA (cyber-ed-WEB-SRV-CA). Вот что это было:

![image.png](images/image.png)

Для этого в mmc.exe мы добавляем оснастку Certificates для Computer Account - где в качестве компьютера мы выбираем web-srv (так как он является ЦС):

![Untitled](images/Untitled%2077.png)

![Untitled](images/Untitled%2078.png)

![Untitled](images/Untitled%2079.png)

Далее заходим в Personal ⇒ Certificates и видим наш корневой сертификат:

![Untitled](images/Untitled%2080.png)

Теперь нам необходим его перенсти. Для этого давайте его экспортируем:

Для этого ПКМ по сертификату ⇒ All Tasks ⇒ Export…:

![Untitled](images/Untitled%2081.png)

Далее Next ⇒ Next ⇒ Next ⇒ Выбираем куда экспортируем ⇒ Next ⇒ Finish.

### Переходим на Windows 10

В идеале я сейчас должен все раскатить с помощью GPO, чтобы автоматически наши клиенты получали сертификаты. А мы сейчас хотим запросить сертификат.

Однако предварительно необходимо установить корневой сертификат, который мы только что эскпортировали, на Windows 10.

Для этого в проводнике в Network подключаемся к сетевой шаре DC1, куда экспортировали сертификат:

**\\192.168.10.200\C$** ⇒ авторизуемся ⇒ копируем сертификат к нам на Windows 10.

Теперь Double Click по сертификату ⇒ Открыть:

![Untitled](images/Untitled%2082.png)

Теперь Установить сертификат…:

![Untitled](images/Untitled%2083.png)

Далее выбираем для локального компьютера:

![Untitled](images/Untitled%2084.png)

Далее помещаем сертификат в следующее хранилище ⇒ Доверенные корневые центры сертификации:

![Untitled](images/Untitled%2085.png)

Давайте запустим от Администратора mmc.exe ⇒ добавим оснастку Сертификаты для УЗ компьютера:

![Untitled](images/Untitled%2086.png)

И тут мы видим, что личных сертификатов на компьютер у меня тут нет:

![Untitled](images/Untitled%2087.png)

Чтобы запросить сертификат:

Личное ⇒ Все задачи ⇒ Запросить новый сертификат…:

![Untitled](images/Untitled%2088.png)

Нажимаем Далее ⇒ Далее ⇒ Ставим галочку на “Показать все шаблоны” ⇒ Выбираем наш шаблон:

![Untitled](images/Untitled%2089.png)

И теперь на ЦС web-srv в Certification Authority мы видим в Issued Certificates, что сертификат был выдан:

![Untitled](images/Untitled%2090.png)